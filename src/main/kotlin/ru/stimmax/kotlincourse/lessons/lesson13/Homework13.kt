package org.example.ru.stimmax.kotlincourse.lessons.lesson13

fun main() {
    // 1. Дан словарь с именем и временем выполнения каждого автоматизированного теста в секундах.
    // Определите среднее время выполнения теста.
    val m1 = mapOf(
        "test1" to 14,
        "test2" to 22,
        "test3" to 1341,
        "test4" to 11
    )
    val a1 = m1.values.average()

    // 2. Имеется словарь с метаданными автоматизированных тестов, где ключи — это имена тестовых методов а значения
    //  - строка с метаданными. Выведите список всех тестовых методов.
    val m2 = mapOf(
        "test1" to listOf("component", "regression"),
        "test2" to listOf("smoke", "newfeature"),
        "test3" to listOf("e2e", "localization"),
    )
    println(m2.keys)

    // 3. В изменяемый словарь с данными о прохождении тестов добавьте новый тест и его результат.
    val m3 = mutableMapOf(
        "test1" to "passed",
        "test2" to "faile",
        "test3" to "skipped",
        "test4" to "warning"
    )
    m3["test5"] = "passed"

    // 4. Посчитайте количество успешных тестов в словаре с результатами (ключ - название, значение - результат из
    // passed, failed, skipped)
    val a4 = m3.count { it.value == "passed" }

    // 5. Удалите из изменяемого словаря с баг-трекингом запись о баге, который был исправлен (ключ - название,
    // значение - статус исправления).
    val m5 = mutableMapOf(
        "bug1" to "fixed",
        "bug2" to "opened",
        "bug3" to "in code review",
        "bug4" to "fixed"
    )
    val m55 = m5.filter { it.value != "fixed" }

    // 6. Для словаря с результатами тестирования веб-страниц (ключ — URL страницы, значение — статус ответа),
    // выведите сообщение о странице и статусе её проверки.
    val m6 = mapOf(
        "url1" to "passed",
        "url2" to "failed",
        "url3" to "failed",
        "url4" to "passed"
    )
    m6.forEach {
        println("${it.key} testing is ${it.value}")
    }

    // 7. Найдите в словаре с названием и временем ответа сервисов только те,
    // время ответа которых превышает заданный порог.
    val m7 = mapOf(
        "service1" to 1.5,
        "service2" to 123.2,
        "service3" to 421.1,
        "service4" to 11.1
    )
    val m77 = m7.filter { it.value > 15 }

    // 8. В словаре хранятся результаты тестирования API (ключ — endpoint, значение — статус ответа в виде строки).
    // Для указанного endpoint найдите статус ответа, если endpoint отсутствует, предположите, что он не был протестирован.
    val m8 = mapOf(
        "ep1" to "passed",
        "ep2" to "failed",
        "ep3" to "failed",
        "ep4" to "passed"
    )
    val m88 = m8.getOrElse("ep7") {
        println("ep7 wasn't tested")
    }

    // 9. Из словаря, содержащего конфигурации тестового окружения (ключ — название параметра конфигурации, значение -
    // сама конфигурация), получите значение для "browserType". Ответ не может быть null.
    val m9 = mapOf(
        "ep1" to "passed",
        "ep2" to "failed",
        "ep3" to "failed",
        "ep4" to "passed"
    )
    m9.getOrDefault("browserType", "No browserType")

    // 10. Создайте копию неизменяемого словаря с данными о версиях тестируемого ПО, добавив новую версию.
    val m10 = mapOf(
        "windows" to 7,
        "macos" to 10.11,
        "linux" to 11011,
    )
    val m1010 = m10.toMutableMap()
    m1010["windows"] = 10

    // 11. Используя словарь с настройками тестирования для различных мобильных устройств (ключ — модель устройства,
    // значение - строка с настройками), получите настройки для конкретной модели или верните настройки по умолчанию.
    val m11 = mapOf(
        "android" to listOf("setting1", "setting2"),
        "android2" to listOf("setting2", "setting3"),
        "linux" to listOf("settings101"),
    )
    val m1111 = m11.getOrDefault("jamsung", listOf("defaultsetting1", "defaultsetting2"))

    // 12. Проверьте, содержит ли словарь с ошибками тестирования (ключ - код ошибки,
    // значение - описание ошибки) определенный код ошибки.
    val m12 = mapOf(
        404 to "not found",
        502 to "bad gateway",
        503 to "service unavailable",
    )
    println(m12.keys.contains(200))

    // 13. Дан неизменяемый словарь, где ключи — это идентификаторы тестовых сценариев в формате "TestID_Version",
    // а значения — статусы выполнения этих тестов ("Passed", "Failed", "Skipped"). Отфильтруйте словарь,
    // оставив только те сценарии, идентификаторы которых соответствуют определённой версии тестов,
    // то-есть в ключе содержится требуемая версия.
    val m13 = mapOf(
        "123_3" to "Passed",
        "432_4" to "Skipped",
        "432_9" to "Failed"
    )
    val m1313 = m13.filter { it.key.split("_")[1].toInt() == 10 }

    // 14. У вас есть словарь, где ключи — это названия функциональных модулей приложения, а значения —
    // результаты их тестирования. Проверьте, есть ли модули с неудачным тестированием.
    println(m9.values.contains("failed"))

    // 15. Добавьте в изменяемый словарь с настройками тестовой среды настройки из другого словаря
    val m15 = mutableMapOf(
        "windows1" to listOf("setting2")
    )
    m11.forEach {
        m15[it.key] = it.value
    }

    // 16. Объедините два неизменяемых словаря с данными о багах.
    val m161 = mutableMapOf(
        "bug1" to "fixed",
        "bug2" to "opened",
        "bug3" to "in code review",
        "bug4" to "fixed"
    )
    val m162 = mapOf(
        "bug5" to "fixed",
        "bug6" to "opened",
        "bug7" to "in code review"
    )
    m162.forEach {
        m161[it.key] = it.value
    }

    // 17. Очистите изменяемый словарь с временными данными о последнем прогоне автоматизированных тестов.
    val m17 = m9.toMutableMap()
    m17.clear()

    // 18. Исключите из отчета по автоматизированному тестированию те случаи, где тесты были пропущены (имеют
    // статус “skipped”). Ключи - название теста, значения - статус.
    val m18 = m3.filter { it.value != "skipped" }

    // 19. Создайте копию словаря с конфигурациями тестирования удалив из него несколько конфигураций.
    val m19 = m15.remove("windows1")

    // 20. Создайте отчет о тестировании, преобразовав словарь с результатами тестирования (ключ — идентификатор теста,
    // значение — результат) в список строк формата "Test ID: результат"
    val m13results = m13.map { "${it.key} costs: ${it.value}" }

    // 21. Преобразуйте изменяемый словарь с результатами последнего тестирования в неизменяемый для архивации.
    val m21 = m3.toMap()

    // 22. Преобразуйте словарь, содержащий числовой ID теста и данные о времени выполнения тестов, заменив
    // идентификаторы тестов на их строковый аналог (например через toString()).
    val m2222 = mapOf(
        "test1" to 14,
        "test2" to 22,
        "test3" to 1341,
        "test4" to 11
    )
    val m22 = m2222.mapValues { it.value.toString() }

    // 23. Для словаря с оценками производительности различных версий приложения (ключи - строковая версия,
    // значения - дробное число времени ответа сервера) увеличьте каждую оценку на 10%,
    // чтобы учесть новые условия тестирования.
    val m23 = mapOf(
        "test1" to 14.21,
        "test2" to 22.354,
        "test3" to 1341.63,
        "test4" to 11.11
    )
    val m2323 = m23.mapValues { it.value * 1.1 }

    // 24. Проверьте, пуст ли словарь с ошибками компиляции тестов.
    println(m3.isEmpty())

    // 25. Убедитесь, что словарь с результатами нагрузочного тестирования не пуст.
    println(m3.isNotEmpty())

    // 26. Проверьте, прошли ли успешно все автоматизированные тесты в словаре с результатами.
    val a26 = m3.all { it.value == "passed" }

    // 27. Определите, содержит ли словарь с результатами тестирования хотя бы один тест с ошибкой.
    val a27 = m3.any { it.value == "failed" }

    // 28. Отфильтруйте словарь с результатами тестирования сервисов, оставив только те тесты,
    // которые не прошли успешно и содержат в названии “optional”.
    val m28 = mapOf(
        "service1" to "passed",
        "service2_optional" to "failed",
        "service3" to "failed",
        "service4_optional" to "passed"
    )
    val m2828 = m28.filter { it.value == "failed" && it.key.contains("optional") }

}